{"version":3,"sources":["../../src/core/notation.js"],"names":["ERR","SOURCE","DEST","NOTATION","NOTA_OBJ","NO_INDEX","NO_PROP","reMATCHER","reVALIDATOR","RegExp","DEFAULT_OPTS","Object","freeze","strict","preserveIndices","Notation","source","options","src","arguments","length","utils","isCollection","NotationError","_source","_isArray","isArray","callback","_each","notation","level","eachNote","levelNotation","note","index","list","hasOwn","undefined","each","push","o","key","value","create","merge","expand","result","has","parent","lastNoteNormalized","normalizeNote","lastNote","parentIsArray","Error","parentNotation","get","last","splice","inspect","defaultValue","msg","overwrite","trim","currentIsLast","nCurrentNote","nNextNote","nextIsArrayNote","notationsObject","isObject","keys","set","notations","inspectRemove","globNotations","original","copy","deepCopy","re","globs","NotationGlob","normalize","len","empty","NEGATE_ALL","test","firstIsWildcard","WILDCARD","filtered","shift","g","endStar","normalized","globNotation","absGlob","slice","indexOf","isNegated","remove","copyFrom","originalNotation","destination","newNotation","newN","getNewNotation","target","moveTo","rename","copyTo","extract","extrude","_options","isValid","match","notes","joinNotes","split","countNotes","replace","levelNotes","join","Glob","collection","topSource","byLevel","eachItem","keyOrIndex","currentNotation"],"mappings":"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","sourcesContent":["/* eslint no-use-before-define:0, consistent-return:0 */\n\nimport NotationError from './notation.error';\nimport NotationGlob from './notation.glob';\nimport utils from '../utils';\n\nconst ERR = {\n    SOURCE: 'Invalid source. Expected a data object or array.',\n    DEST: 'Invalid destination. Expected a data object or array.',\n    NOTATION: 'Invalid notation: ',\n    NOTA_OBJ: 'Invalid notations object. ',\n    NO_INDEX: 'Implied index does not exist: ',\n    NO_PROP: 'Implied property does not exist: '\n};\n\n// created test @ https://regex101.com/r/vLE16M/2\nconst reMATCHER = /(\\[(\\d+|\".*\"|'.*'|`.*`)\\]|[a-z$_][a-z$_\\d]*)/gi;\n// created test @ https://regex101.com/r/fL3PJt/1/\n// /^([a-z$_][a-z$_\\d]*|\\[(\\d+|\".*\"|'.*'|`.*`)\\])(\\[(\\d+|\".*\"|'.*'|`.*`)\\]|(\\.[a-z$_][a-z$_\\d]*))*$/i\nconst reVALIDATOR = new RegExp(\n    '^('\n    + '[a-z$_][a-z$_\\\\d]*'          // JS variable syntax\n    + '|'                           // OR\n    + '\\\\[(\\\\d+|\".*\"|\\'.*\\')\\\\]'    // array index or object bracket notation\n    + ')'                           // exactly once\n    + '('\n    + '\\\\[(\\\\d+|\".*\"|\\'.*\\')\\\\]'    // followed by same\n    + '|'                           // OR\n    + '\\\\.[a-z$_][a-z$_\\\\d]*'       // dot, then JS variable syntax\n    + ')*'                          // (both) may repeat any number of times\n    + '$'\n    , 'i'\n);\n\nconst DEFAULT_OPTS = Object.freeze({\n    strict: false,\n    preserveIndices: false\n});\n\n/**\n *  Notation.js for Node and Browser.\n *\n *  Like in most programming languages, JavaScript makes use of dot-notation to\n *  access the value of a member of an object (or class). `Notation` class\n *  provides various methods for modifying / processing the contents of the\n *  given object; by parsing object notation strings or globs.\n *\n *  Note that this class will only deal with enumerable properties of the source\n *  object; so it should be used to manipulate data objects. It will not deal\n *  with preserving the prototype-chain of the given object.\n *\n *  @author   Onur Yıldırım <onur@cutepilot.com>\n *  @license  MIT\n */\nclass Notation {\n\n    /**\n     *  Initializes a new instance of `Notation`.\n     *\n     *  @param {Object|Array} [source={}] - The source object (or array) to be\n     *  notated. Can either be an array or object. If omitted, defaults to an\n     *  empty object.\n     *  @param {Object} [options] - Notation options.\n     *      @param {Boolean} [options.strict=false] - Whether to throw either when\n     *      a notation path does not exist on the source (i.e. `#get()` and `#remove()`\n     *      methods); or notation path exists but overwriting is disabled (i.e.\n     *      `#set()` method). (Note that `.inspect()` and `.inspectRemove()` methods\n     *      are exceptions). It's recommended to set this to `true` and prevent silent\n     *      failures if you're working with sensitive data. Regardless of `strict` option,\n     *      it will always throw on invalid notation syntax or other crucial failures.\n     *      @param {Boolean} [options.preserveIndices=false] - Indicates whether to\n     *      preserve the indices of the parent array when an item is to be removed.\n     *      By default, the item is removed completely at the implied index instead of\n     *      preserving indices by emptying the item (sparse array). So you should mind\n     *      the shifted indices when you remove an item via `.remove()`, `.inspectRemove()`\n     *      or `.filter()`.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  const notation = new Notation(obj);\n     *  notation.get('car.model')   // » \"Charger\"\n     *  notation.remove('car.model').set('car.color', 'red').value\n     *  // » { car: { brand: \"Dodge\", year: 1970, color: \"red\" } }\n     */\n    constructor(source, options) {\n        let src = source;\n        if (arguments.length === 0) {\n            src = {};\n        } else if (!utils.isCollection(source)) {\n            throw new NotationError(ERR.SOURCE);\n        }\n\n        this.options = options;\n        this._source = src;\n        this._isArray = utils.isArray(src);\n    }\n\n    // --------------------------------\n    // INSTANCE PROPERTIES\n    // --------------------------------\n\n    /**\n     *  Gets or sets notation options.\n     *  @type {Object}\n     */\n    get options() {\n        return this._options;\n    }\n\n    set options(value) {\n        this._options = {\n            ...DEFAULT_OPTS,\n            ...(this._options || {}),\n            ...(value || {})\n        };\n    }\n\n    /**\n     *  Gets the value of the source object.\n     *  @type {Object|Array}\n     *\n     *  @example\n     *  const person = { name: \"Onur\" };\n     *  const me = Notation.create(person)\n     *      .set(\"age\", 36)\n     *      .set(\"car.brand\", \"Ford\")\n     *      .set(\"car.model\", \"Mustang\")\n     *      .value;\n     *  console.log(me); // { name: \"Onur\", age: 36, car: { brand: \"Ford\", model: \"Mustang\" } }\n     *  console.log(person === me); // true\n     */\n    get value() {\n        return this._source;\n    }\n\n    // --------------------------------\n    // INSTANCE METHODS\n    // --------------------------------\n\n    /**\n     *  Recursively iterates through each key of the source object and invokes\n     *  the given callback function with parameters, on each non-object value.\n     *\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each on each non-object value. To break out of the loop, return `false`\n     *  from within the callback.\n     *  Callback signature: `callback(notation, key, value, object) { ... }`\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  Notation.create(obj).each(function (notation, key, value, object) {\n     *      console.log(notation, value);\n     *  });\n     *  // \"car.brand\"  \"Dodge\"\n     *  // \"car.model\"  \"Charger\"\n     *  // \"car.year\"  1970\n     */\n    each(callback) {\n        _each(this._source, callback);\n        return this;\n    }\n\n    /**\n     *  Iterates through each note of the given notation string by evaluating\n     *  it on the source object.\n     *\n     *  @param {String} notation - The notation string to be iterated through.\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each iteration. To break out of the loop, return `false` from within\n     *  the callback. Signature: `callback(levelValue, note, index, list)`\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  Notation.create(obj)\n     *      .eachValue(\"car.brand\", function (levelValue, note, index, list) {\n     *          console.log(note, levelValue); // \"car.brand\" \"Dodge\"\n     *      });\n     */\n    eachValue(notation, callback) {\n        let level = this._source;\n        Notation.eachNote(notation, (levelNotation, note, index, list) => {\n            level = utils.hasOwn(level, note) ? level[note] : undefined;\n            if (callback(level, levelNotation, note, index, list) === false) return false;\n\n        });\n        return this;\n    }\n\n    /**\n     *  Gets the list of notations from the source object (keys).\n     *\n     *  @returns {Array} - An array of notation strings.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  const notations = Notation.create(obj).getNotations();\n     *  console.log(notations); // [ \"car.brand\", \"car.model\", \"car.year\" ]\n     */\n    getNotations() {\n        const list = [];\n        this.each(notation => {\n            list.push(notation);\n        });\n        return list;\n    }\n\n    /**\n     *  Flattens the source object to a single-level object with notated keys.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  const flat = Notation.create(obj).flatten().value;\n     *  console.log(flat);\n     *  // { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\n     */\n    flatten() {\n        const o = {};\n        this.each((notation, key, value) => {\n            o[notation] = value;\n        });\n        this._source = o;\n        return this;\n    }\n\n    /**\n     *  Aggregates notated keys of a (single-level) object, and nests them under\n     *  their corresponding properties. This is the opposite of `Notation#flatten`\n     *  method. This might be useful when expanding a flat object fetched from\n     *  a database.\n     *  @alias Notation#aggregate\n     *  @chainable\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\n     *  const expanded = Notation.create(obj).expand().value;\n     *  console.log(expanded); // { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     */\n    expand() {\n        this._source = Notation.create({}).merge(this._source).value;\n        return this;\n    }\n\n    /**\n     *  Alias for `#expand`\n     *  @private\n     *  @returns {Notation} -\n     */\n    aggregate() {\n        return this.expand();\n    }\n\n    /**\n     *  Inspects the given notation on the source object by checking\n     *  if the source object actually has the notated property;\n     *  and getting its value if exists.\n     *  @param {String} notation - The notation string to be inspected.\n     *  @returns {InspectResult} - The result object.\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).inspect(\"car.year\");\n     *  // { has: true, value: 1970, lastNote: 'year', lastNoteNormalized: 'year' }\n     *  Notation.create({ car: { year: 1970 } }).inspect(\"car.color\");\n     *  // { has: false }\n     *  Notation.create({ car: { color: undefined } }).inspect(\"car.color\");\n     *  // { has: true, value: undefined, lastNote: 'color', lastNoteNormalized: 'color' }\n     *  Notation.create({ car: { brands: ['Ford', 'Dodge'] } }).inspect(\"car.brands[1]\");\n     *  // { has: true, value: 'Dodge', lastNote: '[1]', lastNoteNormalized: 1 }\n     */\n    inspect(notation) {\n        let level = this._source;\n        let result = { has: false, value: undefined };\n        let parent;\n        Notation.eachNote(notation, (levelNotation, note) => {\n            const lastNoteNormalized = utils.normalizeNote(note);\n            if (utils.hasOwn(level, lastNoteNormalized)) {\n                level = level[lastNoteNormalized];\n                parent = level;\n                result = {\n                    notation,\n                    has: true,\n                    value: level,\n                    lastNote: note,\n                    lastNoteNormalized\n                };\n            } else {\n                // level = undefined;\n                result = {\n                    notation,\n                    has: false,\n                    lastNote: note,\n                    lastNoteNormalized\n                };\n                return false; // break out\n            }\n        });\n\n        if (parent === undefined || (result.has && parent === result.value)) parent = this._source;\n        result.parentIsArray = utils.isArray(parent);\n\n        return result;\n    }\n\n    /**\n     *  Notation inspection result object.\n     *  @typedef Notation~InspectResult\n     *  @type Object\n     *  @property {String} notation - Notation that is inspected.\n     *  @property {Boolean} has - Indicates whether the source object has the\n     *  given notation as a (leveled) enumerable property. If the property\n     *  exists but has a value of `undefined`, this will still return `true`.\n     *  @property {*} value - The value of the notated property. If the source\n     *  object does not have the notation, the value will be `undefined`.\n     *  @property {String} lastNote - Last note of the notation, if actually\n     *  exists. For example, last note of `'a.b.c'` is `'c'`.\n     *  @property {String|Number} lastNoteNormalized - Normalized representation\n     *  of the last note of the notation, if actually exists. For example, last\n     *  note of `'a.b[1]` is `'[1]'` and will be normalized to number `1`; which\n     *  indicates an array index.\n     *  @property {Boolean} parentIsArray - Whether the parent object of the\n     *  notation path is an array.\n     */\n\n    /**\n     *  Inspects and removes the given notation from the source object by\n     *  checking if the source object actually has the notated property; and\n     *  getting its value if exists, before removing the property.\n     *\n     *  @param {String} notation - The notation string to be inspected.\n     *\n     *  @returns {InspectResult} - The result object.\n     *\n     *  @example\n     *  let obj = { name: \"John\", car: { year: 1970 } };\n     *  let result = Notation.create(obj).inspectRemove(\"car.year\");\n     *  // result » { notation: \"car.year\", has: true, value: 1970, lastNote: \"year\", lastNoteNormalized: \"year\" }\n     *  // obj » { name: \"John\", car: {} }\n     *\n     *  result = Notation.create({ car: { year: 1970 } }).inspectRemove(\"car.color\");\n     *  // result » { notation: \"car.color\", has: false }\n     *  Notation.create({ car: { color: undefined } }).inspectRemove(\"car['color']\");\n     *  // { notation: \"car.color\", has: true, value: undefined, lastNote: \"['color']\", lastNoteNormalized: \"color\" }\n     *\n     *  let obj = { car: { colors: [\"black\", \"white\"] } };\n     *  let result = Notation.create().inspectRemove(\"car.colors[0]\");\n     *  // result » { notation: \"car.colors[0]\", has: true, value: \"black\", lastNote: \"[0]\", lastNoteNormalized: 0 }\n     *  // obj » { car: { colors: [(empty), \"white\"] } }\n     */\n    inspectRemove(notation) {\n        if (!notation) throw new Error(ERR.NOTATION + `'${notation}'`);\n        const parentNotation = Notation.parent(notation);\n        const parent = parentNotation ? this.get(parentNotation, null) : this._source;\n        const parentIsArray = utils.isArray(parent);\n        const lastNote = Notation.last(notation);\n        const lastNoteNormalized = utils.normalizeNote(lastNote);\n\n        let result;\n        if (utils.hasOwn(parent, lastNoteNormalized)) {\n            result = {\n                notation,\n                has: true,\n                value: parent[lastNoteNormalized],\n                lastNote,\n                lastNoteNormalized,\n                parentIsArray\n            };\n\n            // if `preserveIndices` is enabled and this is an array, we'll\n            // splice the item out. otherwise, we'll use `delete` syntax to\n            // empty the item.\n            if (!this.options.preserveIndices && parentIsArray) {\n                parent.splice(lastNoteNormalized, 1);\n            } else {\n                delete parent[lastNoteNormalized];\n            }\n        } else {\n            result = {\n                notation,\n                has: false,\n                lastNote,\n                lastNoteNormalized,\n                parentIsArray\n            };\n        }\n\n        return result;\n    }\n\n    /**\n     *  Checks whether the source object has the given notation\n     *  as a (leveled) enumerable property. If the property exists\n     *  but has a value of `undefined`, this will still return `true`.\n     *  @param {String} notation - The notation string to be checked.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).has(\"car.year\"); // true\n     *  Notation.create({ car: { year: undefined } }).has(\"car.year\"); // true\n     *  Notation.create({}).has(\"car.color\"); // false\n     */\n    has(notation) {\n        return this.inspect(notation).has;\n    }\n\n    /**\n     *  Checks whether the source object has the given notation\n     *  as a (leveled) defined enumerable property. If the property\n     *  exists but has a value of `undefined`, this will return `false`.\n     *  @param {String} notation - The notation string to be checked.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).hasDefined(\"car.year\"); // true\n     *  Notation.create({ car: { year: undefined } }).hasDefined(\"car.year\"); // false\n     *  Notation.create({}).hasDefined(\"car.color\"); // false\n     */\n    hasDefined(notation) {\n        return this.inspect(notation).value !== undefined;\n    }\n\n    /**\n     *  Gets the value of the corresponding property at the given notation.\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *  @param {String} [defaultValue] - The default value to be returned if the\n     *  property is not found or enumerable.\n     *\n     *  @returns {*} - The value of the notated property.\n     *  @throws {NotationError} - If `strict` option is enabled, `defaultValue`\n     *  is not set and notation does not exist.\n     *\n     *  @example\n     *  Notation.create({ car: { brand: \"Dodge\" } }).get(\"car.brand\"); // \"Dodge\"\n     *  Notation.create({ car: {} }).get(\"car.model\", \"Challenger\"); // \"Challenger\"\n     *  Notation.create({ car: { model: undefined } }).get(\"car.model\", \"Challenger\"); // undefined\n     *\n     *  @example <caption>get value when strict option is enabled</caption>\n     *  // strict option defaults to false\n     *  Notation.create({ car: {} }).get(\"car.model\"); // undefined\n     *  Notation.create({ car: {} }, { strict: false }).get(\"car.model\"); // undefined\n     *  // below will throw bec. strict = true, car.model does not exist\n     *  // and no default value is given.\n     *  Notation.create({ car: {} }, { strict: true }).get(\"car.model\");\n     */\n    get(notation, defaultValue) {\n        const result = this.inspect(notation);\n        // if strict and no default value is set, check if implied index or prop\n        // exists\n        if (this.options.strict && arguments.length < 2 && !result.has) {\n            const msg = result.parentIsArray ? ERR.NO_INDEX : ERR.NO_PROP;\n            throw new NotationError(msg + `'${notation}'`);\n        }\n        return result.has ? result.value : defaultValue;\n    }\n\n    /**\n     *  Sets the value of the corresponding property at the given notation. If\n     *  the property does not exist, it will be created and nested at the\n     *  calculated level. If it exists; its value will be overwritten by\n     *  default.\n     *  @chainable\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *  @param {*} value - The value to be set for the notated property.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property if\n     *  exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If strict notation is enabled, `overwrite`\n     *  option is set to `false` and attempted to overwrite an existing value.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 } };\n     *  Notation.create(obj)\n     *      .set(\"car.brand\", \"Ford\")\n     *      .set(\"car.model\", \"Mustang\")\n     *      .set(\"car.year\", 1965, false)\n     *      .set(\"car.color\", \"red\")\n     *      .set(\"boat\", \"none\");\n     *  console.log(obj);\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\n     */\n    set(notation, value, overwrite = true) {\n        if (!notation.trim()) throw new NotationError(ERR.NOTATION + `'${notation}'`);\n\n        let level = this._source;\n        let currentIsLast, nCurrentNote, nNextNote, nextIsArrayNote;\n\n        Notation.eachNote(notation, (levelNotation, note, index, list) => {\n            currentIsLast = index === list.length - 1;\n            nCurrentNote = nNextNote || utils.normalizeNote(note);\n            nNextNote = currentIsLast ? null : utils.normalizeNote(list[index + 1]);\n\n            if (utils.isArray(level) && typeof nCurrentNote !== 'number') {\n                const parent = Notation.parent(levelNotation) || 'source';\n                throw new NotationError(`Cannot set string key '${note}' on array ${parent}`);\n            }\n\n            // check if the property is at this level\n            if (utils.hasOwn(level, nCurrentNote)) {\n                // check if we're at the last level\n                if (currentIsLast) {\n                    // if overwrite is set, assign the value.\n                    if (overwrite) {\n                        level[nCurrentNote] = value;\n                    } else if (this.options.strict) {\n                        throw new NotationError('Cannot overwrite an existing value in strict mode.');\n                    }\n                } else {\n                    // if not, just re-reference the current level.\n                    level = level[nCurrentNote];\n                }\n            } else {\n                // if next normalized note is a number, it indicates that the\n                // current note is actually an array.\n                nextIsArrayNote = typeof nNextNote === 'number';\n\n                // we don't have this property at this level so; if this is the\n                // last level, we set the value if not, we set an empty\n                // collection for the next level\n                level[nCurrentNote] = (currentIsLast ? value : (nextIsArrayNote ? [] : {}));\n                level = level[nCurrentNote];\n            }\n        });\n        return this;\n    }\n\n    /**\n     *  Just like the `.set()` method but instead of a single notation\n     *  string, an object of notations and values can be passed.\n     *  Sets the value of each corresponding property at the given\n     *  notation. If a property does not exist, it will be created\n     *  and nested at the calculated level. If it exists; its value\n     *  will be overwritten by default.\n     *  @chainable\n     *\n     *  @param {Object} notationsObject - The notations object to be processed.\n     *  This can either be a regular object with non-dotted keys\n     *  (which will be merged to the first/root level of the source object);\n     *  or a flattened object with notated (dotted) keys.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite a property if\n     *  exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 } };\n     *  Notation.create(obj).merge({\n     *      \"car.brand\": \"Ford\",\n     *      \"car.model\": \"Mustang\",\n     *      \"car.year\": 1965,\n     *      \"car.color\": \"red\",\n     *      \"boat\": \"none\"\n     *  });\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\n     */\n    merge(notationsObject, overwrite = true) {\n        if (!utils.isObject(notationsObject)) {\n            throw new NotationError(ERR.NOTA_OBJ + 'Expected an object.');\n        }\n        let value;\n        utils.each(Object.keys(notationsObject), notation => {\n            value = notationsObject[notation];\n            this.set(notation, value, overwrite);\n        });\n        return this;\n    }\n\n    /**\n     *  Removes the properties by the given list of notations from the source\n     *  object and returns a new object with the removed properties.\n     *  Opposite of `merge()` method.\n     *\n     *  @param {Array} notations - The notations array to be processed.\n     *\n     *  @returns {Object} - An object with the removed properties.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 }, notebook: \"Mac\" };\n     *  const separated = Notation.create(obj).separate([\"car.brand\", \"boat\" ]);\n     *  console.log(separated);\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\" } };\n     *  console.log(obj);\n     *  // { car: { year: 1970 } };\n     */\n    separate(notations) {\n        if (!utils.isArray(notations)) {\n            throw new NotationError(ERR.NOTA_OBJ + 'Expected an array.');\n        }\n        const o = new Notation({});\n        utils.each(notations, notation => {\n            const result = this.inspectRemove(notation);\n            o.set(notation, result.value);\n        });\n        this._source = o._source;\n        return this;\n    }\n\n    /**\n     *  Deep clones the source object while filtering its properties by the\n     *  given <b>glob</b> notations. Includes all matched properties and removes\n     *  the rest.\n     *\n     *  The difference between regular notations and glob-notations is that;\n     *  with the latter, you can use wildcard stars (*) and negate the notation\n     *  by prepending a bang (!). A negated notation will be excluded.\n     *\n     *  Order of the globs does not matter; they will be logically sorted. Loose\n     *  globs will be processed first and verbose globs or normal notations will\n     *  be processed last. e.g. `[ \"car.model\", \"*\", \"!car.*\" ]` will be\n     *  normalized and sorted as `[ \"*\", \"!car\" ]`.\n     *\n     *  Passing no parameters or passing an empty string (`\"\"` or `[\"\"]`) will\n     *  empty the source object. See `Notation.Glob` class for more information.\n     *\n     *  @param {Array|String} globNotations - Glob notation(s) to be processed.\n     *  @param {Object} [options] - Filtering options.\n     *  @param {Object} [options.normalize=true] - Whether to normalize the glob list\n     *  before filtering.\n     *  @chainable\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self). To\n     *  get the filtered value, call `.value` property on the instance.\n     *\n     *  @example\n     *  const obj = { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970 } };\n     *  const n = Notation.create(obj);\n     *  n.filter([ \"*\", \"!car.year\" ])\n     *  console.log(obj)            // { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\" } }\n     *  n.filter(\"car.brand\").value // { car: { brand: \"Ford\" } }\n     *  console.log(obj)            // { notebook: \"Mac\", car: { model: \"Mustang\" } }\n     *  n.filter().value            // {}\n     *                              // equivalent to n.filter(\"\") or n.filter(\"!*\")\n     */\n    filter(globNotations, options) {\n        const original = this.value;\n        const copy = utils.deepCopy(original);\n        const { re } = utils;\n\n        // ensure array, normalize and sort the globs in logical order. this\n        // also concats the array first (to prevent mutating the original\n        // array).\n        const globs = NotationGlob.normalize(globNotations);\n        const len = globs.length;\n        const empty = this._isArray ? [] : {};\n\n        // if globs is \"\" or [\"\"] set source to empty and return.\n        if (len === 0 || (len === 1 && (!globs[0] || re.NEGATE_ALL.test(globs[0])))) {\n            this._source = empty;\n            return this;\n        }\n\n        const firstIsWildcard = re.WILDCARD.test(globs[0]);\n        // if globs only consist of \"*\" or \"[*]\"; set the \"copy\" as source and\n        // return.\n        if (len === 1 && firstIsWildcard) {\n            this._source = copy;\n            return this;\n        }\n\n        let filtered;\n        // if the first item of sorted globs is \"*\" or \"[*]\" we set the source\n        // to the (full) \"copy\" and remove the wildcard from globs (not to\n        // re-process).\n        if (firstIsWildcard) {\n            filtered = new Notation(copy);\n            globs.shift();\n        } else {\n            // otherwise we set an empty object or array as the source so that\n            // we can add notations/properties to it.\n            filtered = new Notation(empty);\n        }\n\n        let g, endStar, normalized;\n        // iterate through globs\n        utils.each(globs, globNotation => {\n            g = new NotationGlob(globNotation);\n            // set flag that indicates whether the glob ends with `.*`\n            endStar = g.absGlob.slice(-2) === '.*';\n            // get the remaining part as the (extra) normalized glob\n            normalized = endStar ? g.absGlob.slice(0, -2) : g.absGlob;\n            // normalized = endStar ? g.absGlob.replace(/(\\.\\*)+$/, '') : g.absGlob;\n            // check if normalized glob has no wildcard stars e.g. \"a.b\" or\n            // \"!a.b.c\" etc..\n            if (normalized.indexOf('*') < 0) {\n                if (g.isNegated) {\n                    // directly remove the notation if negated\n                    filtered.remove(normalized);\n                    // if original glob had `.*` at the end, it means remove\n                    // contents (not itself). so we'll set an empty object.\n                    // meaning `some.prop` (prop) is removed completely but\n                    // `some.prop.*` (prop) results in `{}`.\n                    if (endStar) filtered.set(normalized, {}, true);\n                } else {\n                    // directly copy the same notation from the original\n                    filtered.copyFrom(original, normalized, null, true);\n                }\n                // move to the next\n                return true;\n            }\n            // if glob has wildcard star(s), we'll iterate through keys of the\n            // source object and see if (full) notation of each key matches\n            // the current glob.\n\n            // TODO: Optimize the loop below. Instead of checking each key's\n            // notation, get the non-star left part of the glob and iterate\n            // that property of the source object.\n            this.each((originalNotation, key, value) => {\n                // console.log('>>', originalNotation);\n\n                // iterating each note of original notation. i.e.:\n                // note1.note2.note3 is iterated from left to right, as:\n                // 'note1', 'note1.note2', 'note1.note2.note3' — in order.\n                Notation.eachNote(originalNotation, levelNotation => {\n                    if (g.test(levelNotation)) {\n                        if (g.isNegated) {\n                            // console.log('removing', levelNotation, 'of', originalNotation);\n                            filtered.remove(levelNotation);\n                            // we break and return early if removed bec. deeper\n                            // level props are also removed with this parent.\n                            // e.g. when 'note1.note2' of 'note1.note2.note3' is\n                            // removed, we no more have 'note3'.\n                            return false;\n                        }\n                        filtered.set(levelNotation, value, true);\n                    }\n                });\n            });\n        });\n        // finally set the filtered's value as the source of our instance and\n        // return.\n        this._source = filtered.value;\n        return this;\n    }\n\n    /**\n     *  Removes the property from the source object, at the given notation.\n     *  @alias Notation#delete\n     *  @chainable\n     *  @param {String} notation - The notation to be inspected.\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *  @throws {NotationError} - If `strict` option is enabled and notation\n     *  does not exist.\n     *\n     *  @example\n     *  const obj = { notebook: \"Mac\", car: { model: \"Mustang\" } };\n     *  Notation.create(obj).remove(\"car.model\");\n     *  console.log(obj); // { notebook: \"Mac\", car: { } }\n     */\n    remove(notation) {\n        const result = this.inspectRemove(notation);\n        // if strict, check if implied index or prop exists\n        if (this.options.strict && !result.has) {\n            const msg = result.parentIsArray ? ERR.NO_INDEX : ERR.NO_PROP;\n            throw new NotationError(msg + `'${notation}'`);\n        }\n        return this;\n    }\n\n    /**\n     *  Alias of `Notation#remove`\n     *  @private\n     *  @param {String} notation -\n     *  @returns {Notation} -\n     */\n    delete(notation) {\n        this.remove(notation);\n        return this;\n    }\n\n    /**\n     *  Clones the `Notation` instance to a new one.\n     *  @returns {Notation} - A new copy of the instance.\n     */\n    clone() {\n        return new Notation(utils.deepCopy(this.value));\n    }\n\n    /**\n     *  Copies the notated property from the source collection and adds it to the\n     *  destination — only if the source object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object|Array} destination - The destination object that the notated\n     *  properties will be copied to.\n     *  @param {String} notation - The notation to get the corresponding property\n     *  from the source object.\n     *  @param {String} [newNotation=null] - The notation to set the source property\n     *  on the destination object. In other words, the copied property will be\n     *  renamed to this value before set on the destination object. If not set,\n     *  `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the destination object if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `destination` is not a valid collection.\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).copyTo(models, \"car.model\", \"ford\");\n     *  console.log(models);\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\n     *  // source object (obj) is not modified\n     */\n    copyTo(destination, notation, newNotation = null, overwrite = true) {\n        if (!utils.isCollection(destination)) throw new NotationError(ERR.DEST);\n        const result = this.inspect(notation);\n        if (result.has) {\n            const newN = utils.getNewNotation(newNotation, notation);\n            new Notation(destination).set(newN, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Copies the notated property from the target collection and adds it to\n     *  (own) source object — only if the target object actually has that\n     *  property. This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object|Array} target - The target collection that the notated\n     *  properties will be copied from.\n     *  @param {String} notation - The notation to get the corresponding\n     *  property from the target object.\n     *  @param {String} [newNotation=null] - The notation to set the copied\n     *  property on our source collection. In other words, the copied property\n     *  will be renamed to this value before set. If not set, `notation`\n     *  argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  our collection if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `target` is not a valid collection.\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).copyFrom(models, \"dodge\", \"car.model\", true);\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\n     *  // models object is not modified\n     */\n    copyFrom(target, notation, newNotation = null, overwrite = true) {\n        if (!utils.isCollection(target)) throw new NotationError(ERR.DEST);\n        const result = new Notation(target).inspect(notation);\n        if (result.has) {\n            const newN = utils.getNewNotation(newNotation, notation);\n            this.set(newN, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Removes the notated property from the source (own) collection and adds\n     *  it to the destination — only if the source collection actually has that\n     *  property. This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object|Array} destination - The destination collection that the\n     *  notated properties will be moved to.\n     *  @param {String} notation - The notation to get the corresponding\n     *  property from the source object.\n     *  @param {String} [newNotation=null] - The notation to set the source\n     *  property on the destination object. In other words, the moved property\n     *  will be renamed to this value before set on the destination object. If\n     *  not set, `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the destination object if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `destination` is not a valid collection.\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).moveTo(models, \"car.model\", \"ford\");\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\" } }\n     *  console.log(models);\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\n     */\n    moveTo(destination, notation, newNotation = null, overwrite = true) {\n        if (!utils.isCollection(destination)) throw new NotationError(ERR.DEST);\n        const result = this.inspectRemove(notation);\n        if (result.has) {\n            const newN = utils.getNewNotation(newNotation, notation);\n            new Notation(destination).set(newN, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Removes the notated property from the target collection and adds it to (own)\n     *  source collection — only if the target object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object|Array} target - The target collection that the notated\n     *  properties will be moved from.\n     *  @param {String} notation - The notation to get the corresponding property\n     *  from the target object.\n     *  @param {String} [newNotation=null] - The notation to set the target\n     *  property on the source object. In other words, the moved property\n     *  will be renamed to this value before set on the source object.\n     *  If not set, `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the source object if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `target` is not a valid collection.\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).moveFrom(models, \"dodge\", \"car.model\", true);\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\n     *  console.log(models);\n     *  // {}\n     */\n    moveFrom(target, notation, newNotation = null, overwrite = true) {\n        if (!utils.isCollection(target)) throw new NotationError(ERR.DEST);\n        const result = new Notation(target).inspectRemove(notation);\n        if (result.has) {\n            const newN = utils.getNewNotation(newNotation, notation);\n            this.set(newN, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Renames the notated property of the source collection by the new notation.\n     *  @alias Notation#renote\n     *  @chainable\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source collection.\n     *  @param {String} newNotation - The new notation for the targeted\n     *  property value. If not set, the source collection will not be modified.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property at\n     *  the new notation, if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  Notation.create(obj)\n     *      .rename(\"car.brand\", \"carBrand\")\n     *      .rename(\"car.model\", \"carModel\");\n     *  console.log(obj);\n     *  // { carBrand: \"Ford\", carModel: \"Mustang\" }\n     */\n    rename(notation, newNotation, overwrite) {\n        return this.moveTo(this._source, notation, newNotation, overwrite);\n    }\n\n    /**\n     *  Alias for `#rename`\n     *  @private\n     *  @param {String} notation -\n     *  @param {String} newNotation -\n     *  @param {Boolean} [overwrite=true] -\n     *  @returns {Notation} -\n     */\n    renote(notation, newNotation, overwrite) {\n        return this.rename(notation, newNotation, overwrite);\n    }\n\n    /**\n     *  Extracts the property at the given notation to a new object by copying\n     *  it from the source collection. This is equivalent to `.copyTo({},\n     *  notation, newNotation)`.\n     *  @alias Notation#copyToNew\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source object.\n     *  @param {String} newNotation - The new notation to be set on the new\n     *  object for the targeted property value. If not set, `notation` argument\n     *  will be used.\n     *\n     *  @returns {Object} - Returns a new object with the notated property.\n     *\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const extracted = Notation.create(obj).extract(\"car.brand\", \"carBrand\");\n     *  console.log(extracted);\n     *  // { carBrand: \"Ford\" }\n     *  // obj is not modified\n     */\n    extract(notation, newNotation) {\n        const o = {};\n        this.copyTo(o, notation, newNotation);\n        return o;\n    }\n\n    /**\n     *  Alias for `#extract`\n     *  @private\n     *  @param {String} notation -\n     *  @param {String} newNotation -\n     *  @returns {Object} -\n     */\n    copyToNew(notation, newNotation) {\n        return this.extract(notation, newNotation);\n    }\n\n    /**\n     *  Extrudes the property at the given notation to a new collection by\n     *  moving it from the source collection. This is equivalent to `.moveTo({},\n     *  notation, newNotation)`.\n     *  @alias Notation#moveToNew\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source object.\n     *  @param {String} newNotation - The new notation to be set on the new\n     *  object for the targeted property value. If not set, `notation` argument\n     *  will be used.\n     *\n     *  @returns {Object} - Returns a new object with the notated property.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const extruded = Notation.create(obj).extrude(\"car.brand\", \"carBrand\");\n     *  console.log(obj);\n     *  // { car: { model: \"Mustang\" } }\n     *  console.log(extruded);\n     *  // { carBrand: \"Ford\" }\n     */\n    extrude(notation, newNotation) {\n        const o = {};\n        this.moveTo(o, notation, newNotation);\n        return o;\n    }\n\n    /**\n     *  Alias for `#extrude`\n     *  @private\n     *  @param {String} notation -\n     *  @param {String} newNotation -\n     *  @returns {Object} -\n     */\n    moveToNew(notation, newNotation) {\n        return this.extrude(notation, newNotation);\n    }\n\n    // --------------------------------\n    // STATIC MEMBERS\n    // --------------------------------\n\n    /**\n     *  Basically constructs a new `Notation` instance.\n     *  @chainable\n     *  @param {Object|Array} [source={}] - The source collection to be notated.\n     *  @param {Object} [options] - Notation options.\n     *      @param {Boolean} [options.strict=false] - Whether to throw when a\n     *      notation path does not exist on the source. (Note that `.inspect()`\n     *      and `.inspectRemove()` methods are exceptions). It's recommended to\n     *      set this to `true` and prevent silent failures if you're working\n     *      with sensitive data. Regardless of `strict` option, it will always\n     *      throw on invalid notation syntax or other crucial failures.\n     *      @param {Boolean} [options.preserveIndices=true] - Indicates whether to\n     *      preserve the indices of the parent array when an item is to be removed.\n     *      By default indices are preserved by emptying the item (sparse array),\n     *      instead of removing the item completely at the index. When this is\n     *      disabled; you should mind the shifted indices when you remove an\n     *      item via `.remove()`, `.inspectRemove()` or `.filter()`.\n     *\n     *  @returns {Notation} - The created instance.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  const notation = Notation.create(obj); // equivalent to new Notation(obj)\n     *  notation.get('car.model')   // » \"Charger\"\n     *  notation.remove('car.model').set('car.color', 'red').value\n     *  // » { car: { brand: \"Dodge\", year: 1970, color: \"red\" } }\n     */\n    static create(source, options) {\n        if (arguments.length === 0) {\n            return new Notation({});\n        }\n        return new Notation(source, options);\n    }\n\n    /**\n     *  Checks whether the given notation string is valid. Note that the star\n     *  (`*`) (which is a valid character, even if irregular) is NOT treated as\n     *  wildcard here. This checks for regular dot-notation, not a glob-notation.\n     *  For glob notation validation, use `Notation.Glob.isValid()` method. Same\n     *  goes for the negation character/prefix (`!`).\n     *\n     *  @param {String} notation - The notation string to be checked.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  Notation.isValid('prop1.prop2.prop3'); // true\n     *  Notation.isValid('x'); // true\n     *  Notation.isValid('x.arr[0].y'); // true\n     *  Notation.isValid('x[\"*\"]'); // true\n     *  Notation.isValid('x.*'); // false (this would be valid for Notation#filter() only or Notation.Glob class)\n     *  Notation.isValid('@1'); // false (should be \"['@1']\")\n     *  Notation.isValid(null); // false\n     */\n    static isValid(notation) {\n        return typeof notation === 'string' && reVALIDATOR.test(notation);\n    }\n\n    /**\n     *  Splits the given notation string into its notes (levels).\n     *  @param {String} notation  Notation string to be splitted.\n     *  @returns {Array} - A string array of notes (levels).\n     *  @throws {NotationError} - If given notation is invalid.\n     */\n    static split(notation) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + `'${notation}'`);\n        }\n        return notation.match(reMATCHER);\n    }\n\n    /**\n     *  Joins the given notes into a notation string.\n     *  @param {String} notes  Notes (levels) to be joined.\n     *  @returns {String}  Joined notation string.\n     */\n    static join(notes) {\n        return utils.joinNotes(notes);\n    }\n\n    /**\n     *  Counts the number of notes/levels in the given notation.\n     *  @alias Notation.countLevels\n     *  @param {String} notation - The notation string to be processed.\n     *  @returns {Number} - Number of notes.\n     *  @throws {NotationError} - If given notation is invalid.\n     */\n    static countNotes(notation) {\n        return Notation.split(notation).length;\n    }\n\n    /**\n     *  Alias of `Notation.countNotes`.\n     *  @private\n     *  @param {String} notation -\n     *  @returns {Number} -\n     */\n    static countLevels(notation) {\n        return Notation.countNotes(notation);\n    }\n\n    /**\n     *  Gets the first (root) note of the notation string.\n     *  @param {String} notation - The notation string to be processed.\n     *  @returns {String} - First note.\n     *  @throws {NotationError} - If given notation is invalid.\n     *\n     *  @example\n     *  Notation.first('first.prop2.last'); // \"first\"\n     */\n    static first(notation) {\n        return Notation.split(notation)[0];\n    }\n\n    /**\n     *  Gets the last note of the notation string.\n     *  @param {String} notation - The notation string to be processed.\n     *  @returns {String} - Last note.\n     *  @throws {NotationError} - If given notation is invalid.\n     *\n     *  @example\n     *  Notation.last('first.prop2.last'); // \"last\"\n     */\n    static last(notation) {\n        const list = Notation.split(notation);\n        return list[list.length - 1];\n    }\n\n    /**\n     *  Gets the parent notation (up to but excluding the last note)\n     *  from the notation string.\n     *  @param {String} notation - The notation string to be processed.\n     *  @returns {String} - Parent note if any. Otherwise, `null`.\n     *  @throws {NotationError} - If given notation is invalid.\n     *\n     *  @example\n     *  Notation.parent('first.prop2.last'); // \"first.prop2\"\n     *  Notation.parent('single'); // null\n     */\n    static parent(notation) {\n        const last = Notation.last(notation);\n        return notation.slice(0, -last.length).replace(/\\.$/, '') || null;\n    }\n\n    /**\n     *  Iterates through each note/level of the given notation string.\n     *  @alias Notation.eachLevel\n     *\n     *  @param {String} notation - The notation string to be iterated through.\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each iteration. To break out of the loop, return `false` from within the\n     *  callback.\n     *  Callback signature: `callback(levelNotation, note, index, list) { ... }`\n     *\n     *  @returns {void}\n     *  @throws {NotationError} - If given notation is invalid.\n     *\n     *  @example\n     *  const notation = 'first.prop2.last';\n     *  Notation.eachNote(notation, function (levelNotation, note, index, list) {\n     *      console.log(index, note, levelNotation);\n     *  });\n     *  // 0  \"first\"             \"first\"\n     *  // 1  \"first.prop2\"       \"prop2\"\n     *  // 2  \"first.prop2.last\"  \"last\"\n     */\n    static eachNote(notation, callback) {\n        const notes = Notation.split(notation);\n        const levelNotes = [];\n        utils.each(notes, (note, index) => {\n            levelNotes.push(note);\n            if (callback(Notation.join(levelNotes), note, index, notes) === false) return false;\n        }, Notation);\n    }\n\n    /**\n     *  Alias of `Notation.eachNote`.\n     *  @private\n     *  @param {String} notation -\n     *  @param {Function} callback -\n     *  @returns {void}\n     */\n    static eachLevel(notation, callback) {\n        Notation.eachNote(notation, callback);\n    }\n\n}\n\n/**\n *  Error class specific to `Notation`.\n *  @private\n *\n *  @class\n *  @see `{@link #Notation.Error}`\n */\nNotation.Error = NotationError;\n\n/**\n *  Utility for validating, comparing and sorting dot-notation globs.\n *  This is internally used by `Notation` class.\n *  @private\n *\n *  @class\n *  @see `{@link #Notation.Glob}`\n */\nNotation.Glob = NotationGlob;\n\n/**\n *  Undocumented\n *  @private\n */\nNotation.utils = utils;\n\n// --------------------------------\n// HELPERS\n// --------------------------------\n\n/**\n *  Deep iterates through each note (level) of each item in the given\n *  collection.\n *  @private\n *  @param {Object|Array} collection  A data object or an array, as the source.\n *  @param {Function} callback  A function to be executed on each iteration,\n *  with the following arguments: `(levelNotation, note, value, collection)`\n *  @param {String} parentNotation  Storage for parent (previous) notation.\n *  @param {Collection} topSource  Storage for initial/main collection.\n *  @param {Boolean} [byLevel=false]  Indicates whether to iterate notations by\n *  each level or by the end value.  For example, if we have a collection of\n *  `{a: { b: true } }`, and `byLevel` is set; the callback will be invoked on\n *  the following notations: `a`, `a.b`. Otherwise, it will be invoked only on\n *  `a.b`.\n *  @returns {void}\n */\nfunction _each(collection, callback, parentNotation, topSource, byLevel = false) { // eslint-disable-line max-params\n    const source = topSource || collection;\n    // if (!utils.isCollection(collection)) throw ... // no need\n    utils.eachItem(collection, (value, keyOrIndex) => {\n        const note = typeof keyOrIndex === 'number'\n            ? `[${keyOrIndex}]`\n            : keyOrIndex;\n        const currentNotation = Notation.join([parentNotation, note]);\n        const isCollection = utils.isCollection(value);\n        // if it's not a collection we'll execute the callback. if it's a\n        // collection but byLevel is set, we'll also execute the callback.\n        if (!isCollection || byLevel) {\n            if (callback(currentNotation, note, value, source) === false) return false;\n        }\n        // deep iterating if collection\n        if (isCollection) _each(value, callback, currentNotation, source, byLevel);\n    });\n}\n\n// --------------------------------\n// EXPORT\n// --------------------------------\n\nexport default Notation;\n"],"file":"notation.js"}