{"version":3,"sources":["../../src/core/notation.glob.js"],"names":["reMATCHER","reVALIDATOR","RegExp","re","utils","ERR_INVALID","NotationGlob","glob","ins","_inspect","notes","split","absGlob","last","length","parent","slice","replace","_","regexp","toRegExp","notation","Notation","isValid","NotationError","_covers","restrictive","_intersect","isNegated","test","console","log","WILDCARDS","g","indexOf","pregQuote","globA","globB","a","b","notesA","notesB","covers","i","_coversNote","bang","len","Math","max","notesI","push","WILDCARD","joinNotes","normalizeGlobStr","normalize","match","wildCountA","wildCountB","globList","sort","compare","original","ensureArray","list","concat","_negFirstSort","_negLastSort","map","negateAll","normalized","ignored","intersections","checkAddIntersection","gA","gB","inter","hasInverted","_invert","eachRight","indexA","NEGATE_ALL","duplicate","hasExactNeg","negCoversPos","negCoveredByPos","negCoveredByNeg","posCoversPos","posCoveredByNeg","posCoveredByPos","indexB","splice","_isReverseOf","coversB","coveredByB","keepNeg","keepPos","keep","Object","keys","globsListA","globsListB","union","notCovered","hasExact","negCoversNeg","posCoversNeg","globsA","globsB","_compareUnion","listA","listB","bIsArr","ARRAY_GLOB_NOTE","_rx"],"mappings":"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","sourcesContent":["/* eslint no-use-before-define:0, consistent-return:0, max-statements:0 */\n\nimport Notation from './notation';\nimport NotationError from './notation.error';\nimport utils from '../utils';\n\n// http://www.linfo.org/wildcard.html\n// http://en.wikipedia.org/wiki/Glob_%28programming%29\n// http://en.wikipedia.org/wiki/Wildcard_character#Computing\n\n// created test @ https://regex101.com/r/U08luj/2\nconst reMATCHER = /(\\[(\\d+|\\*|\".*\"|'.*')\\]|[a-z$_][a-z$_\\d]*|\\*)/gi; // ! negation should be removed first\n// created test @ https://regex101.com/r/mC8unE/3\n// /^!?(\\*|[a-z$_][a-z$_\\d]*|\\[(\\d+|\".*\"|'.*'|`.*`|\\*)\\])(\\[(\\d+|\".*\"|'.*'|`.*`|\\*)\\]|\\.[a-z$_][a-z$_\\d]*|\\.\\*)*$/i\nconst reVALIDATOR = new RegExp(\n    '^'\n    + '!?('                             // optional negation, only in the front\n    + '\\\\*'                             // wildcard star\n    + '|'                               // OR\n    + '[a-z$_][a-z$_\\\\d]*'              // JS variable syntax\n    + '|'                               // OR\n    + '\\\\[(\\\\d+|\\\\*|\".*\"|\\'.*\\')\\\\]'    // array index or wildcard, or object bracket notation\n    + ')'                               // exactly once\n    + '('\n    + '\\\\[(\\\\d+|\\\\*|\".*\"|\\'.*\\')\\\\]'    // followed by same\n    + '|'                               // OR\n    + '\\\\.[a-z$_][a-z$_\\\\d]*'           // dot, then JS variable syntax\n    + '|'                               // OR\n    + '\\\\.\\\\*'                          // dot, then wildcard star\n    + ')*'                              // (both) may repeat any number of times\n    + '$'\n    , 'i'\n);\n\nconst { re } = utils;\nconst ERR_INVALID = 'Invalid glob notation: ';\n\n/**\n *  `Notation.Glob` is a utility for validating, comparing and sorting\n *  dot-notation globs.\n *\n *  You can use {@link http://www.linfo.org/wildcard.html|wildcard} stars `*`\n *  and negate the notation by prepending a bang `!`. A star will include all\n *  the properties at that level and a negated notation will be excluded.\n *  @name Notation.Glob\n *  @memberof! Notation\n *  @class\n *\n *  @example\n *  // for the following object;\n *  { name: 'John', billing: { account: { id: 1, active: true } } };\n *\n *  'billing.account.*'  // represents value `{ id: 1, active: true }`\n *  'billing.account.id' // represents value `1`\n *  '!billing.account.*' // represents value `{ name: 'John' }`\n *  'name' // represents `'John'`\n *  '*' // represents the whole object\n *\n *  @example\n *  var glob = new Notation.Glob('billing.account.*');\n *  glob.test('billing.account.id'); // true\n */\nclass NotationGlob {\n\n    /**\n     *  Constructs a `Notation.Glob` object with the given glob string.\n     *  @constructs Notation.Glob\n     *  @param {String} glob - Notation string with globs.\n     *\n     *  @throws {NotationError} - If given notation glob is invalid.\n     */\n    constructor(glob) {\n        const ins = NotationGlob._inspect(glob);\n        const notes = NotationGlob.split(ins.absGlob, true);\n        const last = notes[notes.length - 1];\n        const parent = notes.length > 1\n            ? ins.absGlob.slice(0, -last.length).replace(/\\.$/, '')\n            : null;\n        this._ = {\n            ...ins,\n            regexp: NotationGlob.toRegExp(ins.absGlob),\n            notes,\n            last,\n            parent\n        };\n    }\n\n    // --------------------------------\n    // INSTANCE PROPERTIES\n    // --------------------------------\n\n    /**\n     *  Gets the normalized glob notation string.\n     *  @name Notation.Glob#glob\n     *  @type {String}\n     */\n    get glob() {\n        return this._.glob;\n    }\n\n    /**\n     *  Gets the absolute glob notation without the negation prefix `!` and\n     *  redundant trailing wildcards.\n     *  @name Notation.Glob#absGlob\n     *  @type {String}\n     */\n    get absGlob() {\n        return this._.absGlob;\n    }\n\n    /**\n     *  Specifies whether this glob is negated with a `!` prefix.\n     *  @name Notation.Glob#isNegated\n     *  @type {Boolean}\n     */\n    get isNegated() {\n        return this._.isNegated;\n    }\n\n    /**\n     *  Represents this glob in regular expressions.\n     *  Note that the negation prefix (`!`) is ignored, if any.\n     *  @name Notation.Glob#regexp\n     *  @type {RegExp}\n     */\n    get regexp() {\n        return this._.regexp;\n    }\n\n    /**\n     *  List of notes/levels of this glob notation. Note that trailing,\n     *  redundant wildcards are removed from the original glob notation.\n     *  @name Notation.Glob#notes\n     *  @alias Notation.Glob#levels\n     *  @type {Array}\n     */\n    get notes() {\n        return this._.notes;\n    }\n\n    /**\n     *  Alias of `Notation.Glob#notes`.\n     *  @private\n     *  @name Notation.Glob#notes\n     *  @alias Notation.Glob#levels\n     *  @type {Array}\n     */\n    get levels() {\n        return this._.notes;\n    }\n\n    /**\n     *  Gets the first note of this glob notation.\n     *  @name Notation.Glob#first\n     *  @type {String}\n     */\n    get first() {\n        return this.notes[0];\n    }\n\n    /**\n     *  Gets the last note of this glob notation.\n     *  @name Notation.Glob#last\n     *  @type {String}\n     */\n    get last() {\n        return this._.last;\n    }\n\n    /**\n     *  Gets the parent notation (up to but excluding the last note) from the\n     *  glob notation string. Note that initially, trailing/redundant wildcards\n     *  are removed.\n     *  @name Notation.Glob#parent\n     *  @type {String}\n     *\n     *  @example\n     *  NotationGlob.create('first.second.*').parent; // \"first.second\"\n     *  NotationGlob.create('*.x.*').parent; // \"*\"\n     *  NotationGlob.create('*').parent; // null (no parent)\n     */\n    get parent() {\n        return this._.parent;\n    }\n\n    // --------------------------------\n    // INSTANCE METHODS\n    // --------------------------------\n\n    /**\n     *  Checks whether the given notation value matches the source notation\n     *  glob.\n     *  @name Notation.Glob#test\n     *  @function\n     *  @param {String} notation - The notation string to be tested. Cannot have\n     *  any globs.\n     *  @returns {Boolean} -\n     *  @throws {NotationError} - If given `notation` is not valid or contains\n     *  any globs.\n     *\n     *  @example\n     *  const glob = new Notation.Glob('!prop.*.name');\n     *  glob.test(\"prop.account.name\"); // true\n     */\n    test(notation) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(`Invalid notation: '${notation}'`);\n        }\n        // return this.regexp.test(notation);\n        return NotationGlob._covers(this, notation);\n    }\n\n    /**\n     *  Specifies whether this glob notation can represent (or cover) the given\n     *  glob notation. Note that negation prefix is ignored, if any.\n     *  @param {String|Array|NotationGlob} glob  Glob notation string, glob\n     *  notes array or a `NotationGlob` instance.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  const glob = Notation.Glob.create;\n     *  glob('*.y').covers('x.y')      // true\n     *  glob('x[*].y').covers('x[*]')  // false\n     */\n    covers(glob) {\n        return NotationGlob._covers(this, glob);\n    }\n\n    /**\n     *  Gets the intersection of this and the given glob notations. When\n     *  restrictive, if any one of them is negated, the outcome is negated.\n     *  Otherwise, only if both of them are negated, the outcome is negated.\n     *  @param {String} glob - Second glob to be used.\n     *  @param {Boolean} [restrictive=false] - Whether the intersection should\n     *  be negated when one of the globs is negated.\n     *  @returns {String} - Intersection notation if any; otherwise `null`.\n     *  @example\n     *  const glob = Notation.Glob.create;\n     *  glob('x.*').intersect('!*.y')         // 'x.y'\n     *  glob('x.*').intersect('!*.y', true)   // '!x.y'\n     */\n    intersect(glob, restrictive = false) {\n        return NotationGlob._intersect(this.glob, glob, restrictive);\n    }\n\n    // --------------------------------\n    // STATIC MEMBERS\n    // --------------------------------\n\n    /**\n     *  Basically constructs a new `NotationGlob` instance\n     *  with the given glob string.\n     *  @name Notation.Glob.create\n     *  @function\n     *  @param {String} glob - The source notation glob.\n     *  @returns {NotationGlob} -\n     *\n     *  @example\n     *  const glob = Notation.Glob.create(strGlob);\n     *  // equivalent to:\n     *  const glob = new Notation.Glob(strGlob);\n     */\n    static create(glob) {\n        return new NotationGlob(glob);\n    }\n\n    // Created test at: https://regex101.com/r/tJ7yI9/4\n    /**\n     *  Validates the given notation glob.\n     *  @name Notation.Glob.isValid\n     *  @function\n     *\n     *  @param {String} glob - Notation glob to be validated.\n     *  @returns {Boolean} -\n     */\n    static isValid(glob) {\n        return typeof glob === 'string' && reVALIDATOR.test(glob);\n    }\n\n    /**\n     *  Specifies whether the given glob notation includes any valid wildcards\n     *  or negation bang prefix.\n     *  @param {String} glob - Glob notation to be checked.\n     *  @returns {Boolean} -\n     */\n    static hasMagic(glob) {\n        console.log('NotationGlob.isValid', glob, NotationGlob.isValid(glob));\n        console.log('re.WILDCARDS.test', glob, re.WILDCARDS.test(glob));\n        console.log('glob[0] === !', glob, glob[0] === '!');\n        return NotationGlob.isValid(glob)\n            && (re.WILDCARDS.test(glob) || glob[0] === '!');\n    }\n\n    /**\n     *  Gets a regular expressions instance from the given glob notation.\n     *  Note that the bang `!` prefix will be ignored if the given glob is negated.\n     *  @name Notation.Glob.toRegExp\n     *  @function\n     *  @param {String} glob - Glob notation to be converted.\n     *\n     *  @returns {RegExp} - A `RegExp` instance from the glob.\n     *\n     *  @throws {NotationError} - If given notation glob is invalid.\n     */\n    static toRegExp(glob) {\n        if (!NotationGlob.isValid(glob)) {\n            throw new NotationError(`${ERR_INVALID} '${glob}'`);\n        }\n\n        let g = glob.indexOf('!') === 0 ? glob.slice(1) : glob;\n        g = utils.pregQuote(g)\n            // `[*]` always represents array index e.g. `[1]`. so we'd replace\n            // `\\[\\*\\]` with `\\[\\d+\\]` but we should also watch for quotes: e.g.\n            // `[\"x[*]y\"]`\n            .replace(/\\\\\\[\\\\\\*\\\\\\](?=(?:[^\"]|\"[^\"]*\")*$)(?=(?:[^']|'[^']*')*$)/g, '\\\\[\\\\d+\\\\]')\n            // `*` within quotes (e.g. ['*']) is non-wildcard, just a regular star char.\n            // `*` outside of quotes is always JS variable syntax e.g. `prop.*`\n            .replace(/\\\\\\*(?=(?:[^\"]|\"[^\"]*\")*$)(?=(?:[^']|'[^']*')*$)/g, '[a-z$_][a-z$_\\\\d]*')\n            .replace(/\\\\\\?/g, '.');\n        return new RegExp('^' + g + '(?:[\\\\[\\\\.].+|$)', 'i');\n        // it should either end ($) or continue with a dot or bracket. So for\n        // example, `company.*` will produce `/^company\\.[a-z$_][a-z$_\\\\d]*(?:[\\\\[|\\\\.].+|$)/`\n        // which will match both `company.name` and `company.address.street` but\n        // will not match `some.company.name`. Also `!password` will not match\n        // `!password_reset`.\n    }\n\n    /**\n     *  Specifies whether first glob notation can represent (or cover) the\n     *  second.\n     *  @private\n     *  @param {String|Object|NotationGlob} globA  Source glob notation string or inspection\n     *  result object or `NotationGlob` instance.\n     *  @param {String|Object|NotationGlob} globB  Glob notation string or inspection result\n     *  object or `NotationGlob` instance.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  const { covers } = NotationGlob;\n     *  covers('*.y', 'x.y')      // true\n     *  covers('x[*].y', 'x[*]')  // false\n     */\n    static _covers(globA, globB) {\n        const a = typeof globA === 'string'\n            ? new NotationGlob(globA)\n            : globA; // assume (globA instanceof NotationGlob || utils.type(globA) === 'object')\n\n        const b = typeof globB === 'string'\n            ? new NotationGlob(globB)\n            : globB;\n\n        const notesA = a.notes || NotationGlob.split(a.absGlob);\n        const notesB = b.notes || NotationGlob.split(b.absGlob);\n\n        // !x.*.* does not cover !x.* or x.* bec. !x.*.* !== x.* !== x\n        // x.*.* covers x.* bec. x.*.* === x.* === x\n        if (a.isNegated && notesA.length > notesB.length) return false;\n\n        let covers = true;\n        for (let i = 0; i < notesA.length; i++) {\n            if (!_coversNote(notesA[i], notesB[i])) {\n                covers = false;\n                break;\n            }\n        }\n        return covers;\n    }\n\n    /**\n     *  Gets the intersection notation of two glob notations. When restrictive,\n     *  if any one of them is negated, the outcome is negated. Otherwise, only\n     *  if both of them are negated, the outcome is negated.\n     *  @private\n     *  @param {String} globA - First glob to be used.\n     *  @param {String} globB - Second glob to be used.\n     *  @param {Boolean} [restrictive=false] - Whether the intersection should\n     *  be negated when one of the globs is negated.\n     *  @returns {String} - Intersection notation if any; otherwise `null`.\n     *  @example\n     *  _intersect('!*.y', 'x.*', false)     // 'x.y'\n     *  _intersect('!*.y', 'x.*', true)      // '!x.y'\n     */\n    static _intersect(globA, globB, restrictive = false) {\n        // const bang = restrictive\n        //     ? (globA[0] === '!' || globB[0] === '!' ? '!' : '')\n        //     : (globA[0] === '!' && globB[0] === '!' ? '!' : '');\n\n        const notesA = NotationGlob.split(globA, true);\n        const notesB = NotationGlob.split(globB, true);\n\n        let bang;\n        if (restrictive) {\n            bang = globA[0] === '!' || globB[0] === '!' ? '!' : '';\n        } else {\n            if (globA[0] === '!' && globB[0] === '!') {\n                bang = '!';\n            } else {\n                bang = ((notesA.length > notesB.length && globA[0] === '!')\n                        || (notesB.length > notesA.length && globB[0] === '!'))\n                    ? '!'\n                    : '';\n            }\n        }\n\n        const len = Math.max(notesA.length, notesB.length);\n        let notesI = [];\n        let a, b;\n        //   x.*  ∩  *.y   »  x.y\n        // x.*.*  ∩  *.y   »  x.y.*\n        // x.*.z  ∩  *.y   »  x.y.z\n        //   x.y  ∩  *.b   »  (n/a)\n        //   x.y  ∩  a.*   »  (n/a)\n        for (let i = 0; i < len; i++) {\n            a = notesA[i];\n            b = notesB[i];\n            if (a === b) {\n                notesI.push(a);\n            } else if (a && re.WILDCARD.test(a)) {\n                if (!b) {\n                    notesI.push(a);\n                } else {\n                    notesI.push(b);\n                }\n            } else if (b && re.WILDCARD.test(b)) {\n                if (!a) {\n                    notesI.push(b);\n                } else {\n                    notesI.push(a);\n                }\n            } else if (a && !b) {\n                notesI.push(a);\n            } else if (!a && b) {\n                notesI.push(b);\n            } else { // if (a !== b) {\n                notesI = [];\n                break;\n            }\n        }\n\n        if (notesI.length > 0) return bang + utils.joinNotes(notesI);\n        return null;\n    }\n\n    /**\n     *  Undocumented.\n     *  @private\n     *  @param {String} glob -\n     *  @returns {Object} -\n     */\n    static _inspect(glob) {\n        const g = utils.normalizeGlobStr(glob);\n        if (!NotationGlob.isValid(g)) {\n            throw new NotationError(`${ERR_INVALID} '${glob}'`);\n        }\n        const isNegated = g[0] === '!';\n        return {\n            glob: g,\n            isNegated,\n            absGlob: isNegated ? g.slice(1) : g\n        };\n    }\n\n    /**\n     *  Splits the given glob notation string into its notes (levels). Note that\n     *  this will exclude the `!` negation prefix, if it exists.\n     *  @param {String} glob  Glob notation string to be splitted.\n     *  @param {String} [normalize=false]  Whether to remove trailing, redundant\n     *  wildcards.\n     *  @returns {Array} - A string array of glob notes (levels).\n     *  @throws {NotationError} - If given glob notation is invalid.\n     *  @example\n     *  Notation.Glob.split('*.list[2].value')  // ['*', 'list', '[2]', 'value']\n     *  // you can get the same result from the .notes property of a Notation.Glob instance.\n     */\n    static split(glob, normalize = false) {\n        if (!NotationGlob.isValid(glob)) {\n            throw new NotationError(`${ERR_INVALID} '${glob}'`);\n        }\n        const g = normalize ? utils.normalizeGlobStr(glob) : glob;\n        return g.replace(/^!/, '').match(reMATCHER);\n    }\n\n    /**\n     *  Compares two given notation globs and returns an integer value as a\n     *  result. This is generally used to sort glob arrays. Loose globs (with\n     *  stars especially closer to beginning of the glob string) and globs\n     *  representing the parent/root of the compared property glob come first.\n     *  Verbose/detailed/exact globs come last. (`* < *.abc < abc`).\n     *\n     *  For instance; `store.address` comes before `store.address.street`. So\n     *  this works both for `*, store.address.street, !store.address` and `*,\n     *  store.address, !store.address.street`. For cases such as `prop.id` vs\n     *  `!prop.id` which represent the same property; the negated glob comes\n     *  last.\n     *  @name Notation.Glob.compare\n     *  @function\n     *\n     *  @param {String} globA - First notation glob to be compared.\n     *  @param {String} globB - Second notation glob to be compared.\n     *\n     *  @returns {Number} - Returns `-1` if `globA` comes first, `1` if `globB`\n     *  comes first and `0` if equivalent priority.\n     *\n     *  @throws {NotationError} - If either `globA` or `globB` is invalid glob\n     *  notation.\n     *\n     *  @example\n     *  const { compare } = Notation.Glob;\n     *  compare('*', 'info.user')               // -1\n     *  compare('*', '[*]')                     // 0\n     *  compare('info.*.name', 'info.user')     // 1\n     */\n    static compare(globA, globB) {\n        // trivial case, both are exactly the same!\n        // or both are wildcard e.g. `*` or `[*]`\n        if (globA === globB || (re.WILDCARD.test(globA) && re.WILDCARD.test(globB))) return 0;\n\n        const { split, _inspect } = NotationGlob;\n\n        const a = _inspect(globA);\n        const b = _inspect(globB);\n        const notesA = split(a.absGlob);\n        const notesB = split(b.absGlob);\n\n        // Check depth (number of levels)\n        if (notesA.length === notesB.length) {\n            // count wildcards\n            const wildCountA = (a.absGlob.match(re.WILDCARDS) || []).length;\n            const wildCountB = (b.absGlob.match(re.WILDCARDS) || []).length;\n            if (wildCountA === wildCountB) {\n                // check for negation\n                if (!a.isNegated && b.isNegated) return -1;\n                if (a.isNegated && !b.isNegated) return 1;\n                // both are negated or neither are, return alphabetical\n                return a.absGlob < b.absGlob ? -1 : (a.absGlob > b.absGlob ? 1 : 0);\n            }\n            return wildCountA > wildCountB ? -1 : 1;\n        }\n\n        return notesA.length < notesB.length ? -1 : 1;\n    }\n\n    /**\n     *  Sorts the notation globs in the given array by their priorities. Loose\n     *  globs (with stars especially closer to beginning of the glob string);\n     *  globs representing the parent/root of the compared property glob come\n     *  first. Verbose/detailed/exact globs come last. (`* < *abc < abc`).\n     *\n     *  For instance; `store.address` comes before `store.address.street`. For\n     *  cases such as `prop.id` vs `!prop.id` which represent the same property;\n     *  the negated glob wins (comes last).\n     *  @name Notation.Glob.sort\n     *  @function\n     *  @param {Array} globList - The notation globs array to be sorted. The\n     *  passed array reference is modified.\n     *  @returns {Array} -\n     *\n     *  @example\n     *  const { sort } = Notation.Glob;\n     *  sort(['!prop.*.name', 'prop.*', 'prop.id'])\n     *  // ['prop.*', 'prop.id', '!prop.*.name'];\n     */\n    static sort(globList) {\n        return globList.sort(NotationGlob.compare);\n    }\n\n    /**\n     *  Normalizes the given notation globs array by removing duplicate or\n     *  redundant items, eliminating extra verbosity (also with intersection\n     *  globs) and returns a priority-sorted globs array.\n     *\n     *  <ul>\n     *  <li>If any exact duplicates found, all except first is removed.\n     *  <br />example: `['car', 'dog', 'car']` normalizes to `['car', 'dog']`.</li>\n     *  <li>If both normal and negated versions of a glob are found, negated wins.\n     *  <br />example: `['*', 'id', '!id']` normalizes to `['*', '!id']`.</li>\n     *  <li>If a glob is covered by another, it's removed.\n     *  <br />example: `['car.*', 'car.model']` normalizes to `['car']`.</li>\n     *  <li>If a negated glob is covered by another glob, it's kept.\n     *  <br />example: `['*', 'car', '!car.model']` normalizes as is.</li>\n     *  <li>If a negated glob is not covered by another or it does not cover any other;\n     *  then we check for for intersection glob. If found, adds them to list;\n     *  removes the original negated.\n     *  <br />example: `['car.*', '!*.model']` normalizes as to `['car', '!car.model']`.</li>\n     *  <li>In restrictive mode; if a glob is covered by another negated glob, it's removed.\n     *  Otherwise, it's kept.\n     *  <br />example: `['*', '!car.*', 'car.model']` normalizes to `['*', '!car']` if restrictive.</li>\n     *  </ul>\n     *  @name Notation.Glob.normalize\n     *  @function\n     *  @param {Array} globList - Notation globs array to be normalized.\n     *  @param {Boolean} [restrictive=false] - Whether negated items strictly\n     *  remove every match. Note that, regardless of this option, if any item has an\n     *  exact negated version; non-negated is always removed.\n     *  @returns {Array} -\n     *\n     *  @throws {NotationError} - If any item in globs list is invalid.\n     *\n     *  @example\n     *  const { normalize } = Notation.Glob;\n     *  const globs = ['*', '!id', 'name', '!car.model', 'car.*', 'id', 'name'];\n     *  normalize(globs)                            // ['*', '!id', '!car.model']\n     *  normalize(['!*.id', 'user.*', 'company'])   // ['company', 'user', '!company.id', '!user.id']\n     */\n    static normalize(globList, restrictive = false) {\n        const { _inspect, _covers, _intersect } = NotationGlob;\n\n        const original = utils.ensureArray(globList);\n\n        const list = original\n            // prevent mutation\n            .concat()\n            // move negated globs to top so that we inspect non-negated globs\n            // against others first. when complete, we'll sort with our\n            // .compare() function.\n            .sort(restrictive ? _negFirstSort : _negLastSort)\n            // turning string array into inspect-obj array, so that we'll not\n            // run _inspect multiple times in the inner loop. this also\n            // pre-validates each glob.\n            .map(_inspect);\n\n        // early return if we have a single item\n        if (list.length === 1) {\n            const g = list[0];\n            // single negated item is redundant\n            if (g.isNegated) return [];\n            // return normalized\n            return [g.glob];\n        }\n\n        // flag to return an empty array (in restrictive mode), if true.\n        let negateAll = false;\n\n        // we'll push keepers in this array\n        let normalized = [];\n        // we'll need to remember excluded globs, so that we can move to next\n        // item early.\n        const ignored = {};\n\n        // storage to keep intersections.\n        // using an object to prevent duplicates.\n        let intersections = {};\n\n        const checkAddIntersection = (gA, gB) => {\n            const inter = _intersect(gA, gB, restrictive);\n            if (!inter) return;\n            // if the intersection result has an inverted version in the\n            // original list, don't add this.\n            const hasInverted = restrictive ? false : original.indexOf(_invert(inter)) >= 0;\n            // also if intersection result is in the current list, don't add it.\n            if (list.indexOf(inter) >= 0 || hasInverted) return;\n            intersections[inter] = inter;\n        };\n\n        // iterate each glob by comparing it to remaining globs.\n        utils.eachRight(list, (a, indexA) => {\n\n            // if `strict` is enabled, return empty if a negate-all is found\n            // (which itself is also redundant if single): '!*' or '![*]'\n            if (re.NEGATE_ALL.test(a.glob)) {\n                negateAll = true;\n                if (restrictive) return false;\n            }\n\n            // flags\n            let duplicate = false;\n            let hasExactNeg = false;\n            // flags for negated\n            let negCoversPos = false;\n            let negCoveredByPos = false;\n            let negCoveredByNeg = false;\n            // flags for non-negated (positive)\n            let posCoversPos = false;\n            let posCoveredByNeg = false;\n            let posCoveredByPos = false;\n\n            utils.eachRight(list, (b, indexB) => {\n                // don't inspect glob with itself\n                if (indexA === indexB) return; // move to next\n                // console.log(indexA, a.glob, 'vs', b.glob);\n\n                // remove if duplicate\n                if (a.glob === b.glob) {\n                    list.splice(indexA, 1);\n                    duplicate = true;\n                    return false; // break out\n                }\n\n                // remove if positive has an exact negated (negated wins when\n                // normalized) e.g. ['*', 'a', '!a'] => ['*', '!a']\n                if (!a.isNegated && _isReverseOf(a, b)) {\n                    // list.splice(indexA, 1);\n                    ignored[a.glob] = true;\n                    hasExactNeg = true;\n                    return false; // break out\n                }\n\n                // if already excluded b, go on to next\n                if (ignored[b.glob]) return; // next\n\n                const coversB = _covers(a, b);\n                const coveredByB = coversB ? false : _covers(b, a);\n                if (a.isNegated) {\n                    if (b.isNegated) {\n                        // if negated (a) covered by any other negated (b); remove (a)!\n                        if (coveredByB) {\n                            negCoveredByNeg = true;\n                            // list.splice(indexA, 1);\n                            ignored[a.glob] = true;\n                            return false; // break out\n                        }\n                    } else {\n                        /* istanbul ignore if */\n                        if (coversB) negCoversPos = true;\n                        if (coveredByB) negCoveredByPos = true;\n                        // try intersection if none covers the other and only\n                        // one of them is negated.\n                        if (!coversB && !coveredByB) {\n                            checkAddIntersection(a.glob, b.glob);\n                        }\n                    }\n                } else {\n                    if (b.isNegated) {\n                        // if positive (a) covered by any negated (b); remove (a)!\n                        if (coveredByB) {\n                            posCoveredByNeg = true;\n                            if (restrictive) {\n                                // list.splice(indexA, 1);\n                                ignored[a.glob] = true;\n                                return false; // break out\n                            }\n                            return; // next\n                        }\n                        // try intersection if none covers the other and only\n                        // one of them is negated.\n                        if (!coversB && !coveredByB) {\n                            checkAddIntersection(a.glob, b.glob);\n                        }\n                    } else {\n                        if (coversB) posCoversPos = coversB;\n                        // if positive (a) covered by any other positive (b); remove (a)!\n                        if (coveredByB) {\n                            posCoveredByPos = true;\n                            if (restrictive) {\n                                // list.splice(indexA, 1);\n                                return false; // break out\n                            }\n                        }\n                    }\n                }\n\n            });\n\n            // const keepNeg = (negCoversPos || negCoveredByPos) && !negCoveredByNeg;\n            const keepNeg = restrictive\n                ? (negCoversPos || negCoveredByPos) && negCoveredByNeg === false\n                : negCoveredByPos && negCoveredByNeg === false;\n            const keepPos = restrictive\n                ? (posCoversPos || posCoveredByPos === false) && posCoveredByNeg === false\n                : posCoveredByNeg || posCoveredByPos === false;\n            const keep = duplicate === false\n                && hasExactNeg === false\n                && (a.isNegated ? keepNeg : keepPos);\n\n            if (keep) {\n                normalized.push(a.glob);\n            } else {\n                // this is excluded from final (normalized) list, so mark as\n                // ignored (don't remove from \"list\" for now)\n                ignored[a.glob] = true;\n            }\n        });\n\n        if (restrictive && negateAll) return [];\n\n        intersections = Object.keys(intersections);\n        if (intersections.length > 0) {\n            // merge normalized list with intersections if any\n            normalized = normalized.concat(intersections);\n            // we have new (intersection) items, so re-normalize\n            return NotationGlob.normalize(normalized, restrictive);\n        }\n\n        return NotationGlob.sort(normalized);\n    }\n\n    /**\n     *  Undocumented. See `.union()`\n     *  @private\n     *  @param {Array} globsListA -\n     *  @param {Array} globsListB -\n     *  @param {Array} union -\n     *  @returns {Array} -\n     */\n    static _compareUnion(globsListA, globsListB, restrictive, union = []) {\n        const { _covers } = NotationGlob;\n\n        const { _inspect, _intersect } = NotationGlob;\n\n        utils.eachRight(globsListA, globA => {\n            if (union.indexOf(globA) >= 0) return; // next\n\n            const a = _inspect(globA);\n\n            // if wildcard only, add...\n            if (re.WILDCARD.test(a.absGlob)) {\n                union.push(a.glob); // push normalized glob\n                return; // next\n            }\n\n            let notCovered = false;\n            let hasExact = false;\n            let negCoversNeg = false;\n            let posCoversNeg = false;\n            let posCoversPos = false;\n            let negCoversPos = false;\n\n            const intersections = [];\n\n            utils.eachRight(globsListB, globB => {\n\n                // keep if has exact in the other\n                if (globA === globB) hasExact = true;\n\n                const b = _inspect(globB);\n\n                // keep negated if:\n                //    1) any negated covers it\n                //    2) no positive covers it\n                // keep positive if:\n                //    1) no positive covers it OR any negated covers it\n\n                notCovered = !_covers(b, a);\n                if (notCovered) {\n                    if (a.isNegated && b.isNegated) {\n                        const inter = _intersect(a.glob, b.glob, restrictive);\n                        if (inter && union.indexOf(inter) === -1) intersections.push(inter);\n                    }\n                    return; // next\n                }\n\n                if (a.isNegated) {\n                    if (b.isNegated) {\n                        negCoversNeg = !hasExact;\n                    } else {\n                        posCoversNeg = true; // set flag\n                    }\n                } else {\n                    if (!b.isNegated) {\n                        posCoversPos = !hasExact;\n                    } else {\n                        negCoversPos = true; // set flag\n                    }\n                }\n\n            });\n\n\n            const keep = a.isNegated\n                ? (!posCoversNeg || negCoversNeg)\n                : (!posCoversPos || negCoversPos);\n\n            if (hasExact || keep || (notCovered && !a.isNegated)) {\n                union.push(a.glob); // push normalized glob\n                return;\n            }\n\n            if (a.isNegated && posCoversNeg && !negCoversNeg && intersections.length > 0) {\n                union = union.concat(intersections); // eslint-disable-line no-param-reassign\n            }\n\n        });\n\n        return union;\n    }\n\n    /**\n     *  Gets the union from the given couple of glob arrays and returns a new\n     *  array of globs.\n     *  <ul>\n     *  <li>If the exact same element is found in both\n     *  arrays, one of them is removed to prevent duplicates.\n     *  <br />example: `['!id', 'name'] ∪ ['!id']` unites to `['!id', 'name']`</li>\n     *  <li>If any non-negated item is covered by a glob in the same\n     *  or other array, the redundant item is removed.\n     *  <br />example: `['*', 'name'] ∪ ['email']` unites to `['*']`</li>\n     *  <li>If one of the arrays contains a negated equivalent of an\n     *  item in the other array, the negated item is removed.\n     *  <br />example: `['!id'] ∪ ['id']` unites to `['id']`</li>\n     *  <li>If any item covers/matches a negated item in the other array,\n     *  the negated item is removed.\n     *  <br />example #1: `['!user.id'] ∪ ['user.*']` unites to `['user']`\n     *  <br />example #2: `['*'] ∪ ['!password']` unites to `['*']`\n     *  </li>\n     *  </ul>\n     *  @name Notation.Glob.union\n     *  @function\n     *\n     *  @param {Array} globsA - First array of glob strings.\n     *  @param {Array} globsB - Second array of glob strings.\n     *  @param {Boolean} [restrictive=false] - Whether negated items in each of\n     *  the lists, strictly remove every match in themselves (not the cross\n     *  list). This option is used when pre-normalizing each glob list and\n     *  normalizing the final union list.\n     *\n     *  @returns {Array} -\n     *\n     *  @example\n     *  const a = ['user.*', '!user.email', 'car.model', '!*.id'];\n     *  const b = ['!*.date', 'user.email', 'car', '*.age'];\n     *  const { union } = Notation.Glob;\n     *  union(a, b)     // ['car', 'user', '*.age', '!car.date', '!user.id']\n     */\n    static union(globsA, globsB, restrictive) {\n        const { normalize, _compareUnion } = NotationGlob;\n\n        const listA = normalize(globsA, restrictive);\n        const listB = normalize(globsB, restrictive);\n\n        if (listA.length === 0) return listB;\n        if (listB.length === 0) return listA;\n\n        // TODO: below should be optimized\n        let union = _compareUnion(listA, listB, restrictive);\n        union = _compareUnion(listB, listA, restrictive, union);\n        return normalize(union, restrictive);\n    }\n\n}\n\n// --------------------------------\n// HELPERS\n// --------------------------------\n\nfunction _coversNote(a, b) {\n    if (a === b) return true;\n    // if (!a && re.WILDCARD.test(b)) return false;\n    const bIsArr = b ? re.ARRAY_GLOB_NOTE.test(b) : null;\n    if (a === '*' && (!b || !bIsArr)) return true;\n    if (a === '[*]' && (!b || bIsArr)) return true;\n    return false;\n}\n\n// x vs !x.*.*      » false\n// x vs !x[*]       » true\n// x[*] vs !x       » true\n// x[*] vs !x[*]    » false\n// x.* vs !x.*      » false\nfunction _isReverseOf(a, b) {\n    return a.isNegated !== b.isNegated\n        && a.absGlob === b.absGlob;\n}\n\nfunction _invert(glob) {\n    return glob[0] === '!' ? glob.slice(1) : '!' + glob;\n}\n\nconst _rx = /^\\s*!/;\nfunction _negFirstSort(a, b) {\n    return _rx.test(a) ? -1 : (_rx.test(b) ? 1 : 0);\n}\nfunction _negLastSort(a, b) {\n    return _rx.test(a) ? 1 : (_rx.test(b) ? -1 : 0);\n}\n\n// --------------------------------\n// EXPORT\n// --------------------------------\n\nexport default NotationGlob;\n"],"file":"notation.glob.js"}